// Code generated by ent, DO NOT EDIT.

package ent

import (
	"encoding/json"
	"fmt"
	"license-manager/pkg/repositories/ent-fw/ent/license"
	"license-manager/pkg/repositories/ent-fw/ent/organization"
	"strings"
	"time"

	"entgo.io/ent/dialect/sql"
)

// License is the model entity for the License schema.
type License struct {
	config `json:"-"`
	// ID of the ent.
	ID string `json:"id,omitempty"`
	// Features holds the value of the "features" field.
	Features string `json:"features,omitempty"`
	// Status holds the value of the "status" field.
	Status string `json:"status,omitempty"`
	// Version holds the value of the "version" field.
	Version string `json:"version,omitempty"`
	// Note holds the value of the "note" field.
	Note string `json:"note,omitempty"`
	// Contact holds the value of the "contact" field.
	Contact string `json:"contact,omitempty"`
	// Mail holds the value of the "mail" field.
	Mail string `json:"mail,omitempty"`
	// Quotas holds the value of the "quotas" field.
	Quotas map[string]string `json:"quotas,omitempty"`
	// Secret holds the value of the "secret" field.
	Secret string `json:"-"`
	// ExpirationDate holds the value of the "expiration_date" field.
	ExpirationDate time.Time `json:"expiration_date,omitempty"`
	// ActivationDate holds the value of the "activation_date" field.
	ActivationDate time.Time `json:"activation_date,omitempty"`
	// LastAccessed holds the value of the "last_accessed" field.
	LastAccessed time.Time `json:"last_accessed,omitempty"`
	// LastAccessIP holds the value of the "last_access_IP" field.
	LastAccessIP string `json:"last_access_IP,omitempty"`
	// AccessCount holds the value of the "access_count" field.
	AccessCount int `json:"access_count,omitempty"`
	// DateCreated holds the value of the "date_created" field.
	DateCreated time.Time `json:"date_created,omitempty"`
	// LastUpdated holds the value of the "last_updated" field.
	LastUpdated time.Time `json:"last_updated,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the LicenseQuery when eager-loading is set.
	Edges                 LicenseEdges `json:"edges"`
	organization_licenses *string
}

// LicenseEdges holds the relations/edges for other nodes in the graph.
type LicenseEdges struct {
	// LicenseProducts holds the value of the license_products edge.
	LicenseProducts []*Product `json:"license_products,omitempty"`
	// OwnerOrg holds the value of the owner_org edge.
	OwnerOrg *Organization `json:"owner_org,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [2]bool
}

// LicenseProductsOrErr returns the LicenseProducts value or an error if the edge
// was not loaded in eager-loading.
func (e LicenseEdges) LicenseProductsOrErr() ([]*Product, error) {
	if e.loadedTypes[0] {
		return e.LicenseProducts, nil
	}
	return nil, &NotLoadedError{edge: "license_products"}
}

// OwnerOrgOrErr returns the OwnerOrg value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e LicenseEdges) OwnerOrgOrErr() (*Organization, error) {
	if e.loadedTypes[1] {
		if e.OwnerOrg == nil {
			// Edge was loaded but was not found.
			return nil, &NotFoundError{label: organization.Label}
		}
		return e.OwnerOrg, nil
	}
	return nil, &NotLoadedError{edge: "owner_org"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*License) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case license.FieldQuotas:
			values[i] = new([]byte)
		case license.FieldAccessCount:
			values[i] = new(sql.NullInt64)
		case license.FieldID, license.FieldFeatures, license.FieldStatus, license.FieldVersion, license.FieldNote, license.FieldContact, license.FieldMail, license.FieldSecret, license.FieldLastAccessIP:
			values[i] = new(sql.NullString)
		case license.FieldExpirationDate, license.FieldActivationDate, license.FieldLastAccessed, license.FieldDateCreated, license.FieldLastUpdated:
			values[i] = new(sql.NullTime)
		case license.ForeignKeys[0]: // organization_licenses
			values[i] = new(sql.NullString)
		default:
			return nil, fmt.Errorf("unexpected column %q for type License", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the License fields.
func (l *License) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case license.FieldID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value.Valid {
				l.ID = value.String
			}
		case license.FieldFeatures:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field features", values[i])
			} else if value.Valid {
				l.Features = value.String
			}
		case license.FieldStatus:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field status", values[i])
			} else if value.Valid {
				l.Status = value.String
			}
		case license.FieldVersion:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field version", values[i])
			} else if value.Valid {
				l.Version = value.String
			}
		case license.FieldNote:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field note", values[i])
			} else if value.Valid {
				l.Note = value.String
			}
		case license.FieldContact:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field contact", values[i])
			} else if value.Valid {
				l.Contact = value.String
			}
		case license.FieldMail:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field mail", values[i])
			} else if value.Valid {
				l.Mail = value.String
			}
		case license.FieldQuotas:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field quotas", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &l.Quotas); err != nil {
					return fmt.Errorf("unmarshal field quotas: %w", err)
				}
			}
		case license.FieldSecret:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field secret", values[i])
			} else if value.Valid {
				l.Secret = value.String
			}
		case license.FieldExpirationDate:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field expiration_date", values[i])
			} else if value.Valid {
				l.ExpirationDate = value.Time
			}
		case license.FieldActivationDate:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field activation_date", values[i])
			} else if value.Valid {
				l.ActivationDate = value.Time
			}
		case license.FieldLastAccessed:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field last_accessed", values[i])
			} else if value.Valid {
				l.LastAccessed = value.Time
			}
		case license.FieldLastAccessIP:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field last_access_IP", values[i])
			} else if value.Valid {
				l.LastAccessIP = value.String
			}
		case license.FieldAccessCount:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field access_count", values[i])
			} else if value.Valid {
				l.AccessCount = int(value.Int64)
			}
		case license.FieldDateCreated:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field date_created", values[i])
			} else if value.Valid {
				l.DateCreated = value.Time
			}
		case license.FieldLastUpdated:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field last_updated", values[i])
			} else if value.Valid {
				l.LastUpdated = value.Time
			}
		case license.ForeignKeys[0]:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field organization_licenses", values[i])
			} else if value.Valid {
				l.organization_licenses = new(string)
				*l.organization_licenses = value.String
			}
		}
	}
	return nil
}

// QueryLicenseProducts queries the "license_products" edge of the License entity.
func (l *License) QueryLicenseProducts() *ProductQuery {
	return NewLicenseClient(l.config).QueryLicenseProducts(l)
}

// QueryOwnerOrg queries the "owner_org" edge of the License entity.
func (l *License) QueryOwnerOrg() *OrganizationQuery {
	return NewLicenseClient(l.config).QueryOwnerOrg(l)
}

// Update returns a builder for updating this License.
// Note that you need to call License.Unwrap() before calling this method if this License
// was returned from a transaction, and the transaction was committed or rolled back.
func (l *License) Update() *LicenseUpdateOne {
	return NewLicenseClient(l.config).UpdateOne(l)
}

// Unwrap unwraps the License entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (l *License) Unwrap() *License {
	_tx, ok := l.config.driver.(*txDriver)
	if !ok {
		panic("ent: License is not a transactional entity")
	}
	l.config.driver = _tx.drv
	return l
}

// String implements the fmt.Stringer.
func (l *License) String() string {
	var builder strings.Builder
	builder.WriteString("License(")
	builder.WriteString(fmt.Sprintf("id=%v, ", l.ID))
	builder.WriteString("features=")
	builder.WriteString(l.Features)
	builder.WriteString(", ")
	builder.WriteString("status=")
	builder.WriteString(l.Status)
	builder.WriteString(", ")
	builder.WriteString("version=")
	builder.WriteString(l.Version)
	builder.WriteString(", ")
	builder.WriteString("note=")
	builder.WriteString(l.Note)
	builder.WriteString(", ")
	builder.WriteString("contact=")
	builder.WriteString(l.Contact)
	builder.WriteString(", ")
	builder.WriteString("mail=")
	builder.WriteString(l.Mail)
	builder.WriteString(", ")
	builder.WriteString("quotas=")
	builder.WriteString(fmt.Sprintf("%v", l.Quotas))
	builder.WriteString(", ")
	builder.WriteString("secret=")
	builder.WriteString(l.Secret)
	builder.WriteString(", ")
	builder.WriteString("expiration_date=")
	builder.WriteString(l.ExpirationDate.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("activation_date=")
	builder.WriteString(l.ActivationDate.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("last_accessed=")
	builder.WriteString(l.LastAccessed.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("last_access_IP=")
	builder.WriteString(l.LastAccessIP)
	builder.WriteString(", ")
	builder.WriteString("access_count=")
	builder.WriteString(fmt.Sprintf("%v", l.AccessCount))
	builder.WriteString(", ")
	builder.WriteString("date_created=")
	builder.WriteString(l.DateCreated.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("last_updated=")
	builder.WriteString(l.LastUpdated.Format(time.ANSIC))
	builder.WriteByte(')')
	return builder.String()
}

// Licenses is a parsable slice of License.
type Licenses []*License

func (l Licenses) config(cfg config) {
	for _i := range l {
		l[_i].config = cfg
	}
}
